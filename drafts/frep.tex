
%% in introduction part:

  The major emphasis of this project had been in the area of development
 tools, platforms and code architecture for embedded software design.
 Though originally it was intended as application development project,
 study of various alternatives of how the task can be achieved lead to
 extended research in embedded operating systems and various programming
 tools (namely compiler toolchains, cross-platform integration techniques
 as well as languages).
  One of initial interest areas had been in the field of networking protocols
 for wireless sensor networks. Current best practice suggests that IP-enabled
 networking technology is most suitable for its global adoption, hence simple
 to integrate with various existing applications. It is rather difficult to
 imagine where in the modern technology world a non-IP network may be useful.
 The closes reference to this can be found in papers published by IPSO 
 \cite{IPSO_PAPERS} and general industry trends. Certainly non-IP networking
 technology is available on the market, however if such device are going to
 used for any application, there are several limitations imposed on integration
 into various existing infrastructures. That implies physical connectivity
 as well as software support. One example is the popular \emph{ZigBee}
 family of protocols, is apparently gaining popularity, thought no global
 scale of deployment has been observed. Instead most of research papers
 are oriented towards the use of IP-enabled networks for wireless sensing.

%%%

  As stated in the interim report, the task which was still to be
 completed then had been the development of radio transceiver driver
 code for the chosen platform (\Chip{ATmega128RFA1}). After spending
 several hours of work, it has been understood that there are various
 in portability of \emph{AVR} architecture code. The \emph{AVR} branch
 of \emph{Contiki OS} (in its current state) has almost no facility to
 aid porting task for various \emph{AVR} devices which may be of some
 interest. Comparing currently available \emph{Atmel AVR} microcontroller
 models \cite{atmel:avr:table}, it is rather clear that OS support for
 this architecture can be generalised to much higher degree then what is
 currently provided by the \emph{Contiki OS}. Due to the time limit for
 this project, various alternatives were considered.

\subsection{TinyOS}

  It has been discovered that a few members of \emph{TinyOS} community
 have recently worked on porting \emph{TinyOS} to run on \Chip{ATmega128RFA1}
 \cite{tinyos:arch:rfa1-p1,tinyos:arch:rfa1-p2}. Comparing to \emph{Contiki},
 \emph{TinyOS} has rather superior abstraction layer that provides a seamless 
 cross-platform integration \cite{tinyos:tepXXX,tinyos:tepYYY,tinyos:tepZZZ}.
 
  Various internal of \emph{TinyOS} had been studied, however it is
 certainly a very broad area to be described here. It is best described
 in the "TinyOS Programming" book by David Gay and Philip Levis (it is
 available in print as well as web-edition \cite{tinyos:book}). Two
 authors of this book are lead developer of the \emph{TinyOS} project
 and are currently working at the University of California, Berkley
 and Standford.

\subsubsection{Programming TinyOS: Compilers and Abstractions}

  The greatest achievement of \emph{TinyOS} is its specialised language,
 benefits of which had been overlooked at the earlier stage of research
 for this project. "Network Embedded Systems C" (nesC) was designed
 especially \dots

 \emph{TinyOS} currently had been ported to a variety of 8-, 16- and
 32-bit microcontrollers, most of the peripherals (such as I2C and SPI)
 have unified high-level access mechanisms, unlike in \emph{Contki}.
 Most of development documentation is provided as "TinyOS Enhancement
 Proposals" (known as TEPs), and there is also documentation generated
 from code (\emph{nescdoc}) as well as various on-line resources and
 the companion book mentioned above. %% REFERENCES NEEDED %%

 It is important to note that current implementation of the compiler
 translates higher-level nesC code into C language. The resulting
 programs are specifically suited for embedded devices. Direct
 compilation would be possible and, if desired, there is an interesting
 platform to look into. \emph{LLVM} ("Low-level Virtual Machine") is a
 new generation compiler technology. It is know that using \emph{LLVM}
 and its family member \emph{clang} implementation of compiler for
 a C-like language would be simplified (comparing to more traditional
 techniques). One good example of industrial grade compiler based on
 \emph{LLVM} is the \emph{XC} toolchain for \emph{XS-1} devices from
 a UK semiconductor company \emph{XMOS} \cite{paper:xmos:docs:xcc}.

 Nevertheless, currently \emph{nesC} compiler is known to be fully
 functional and it's task is not as complex as it may seem. Programming
 in any language is always done by applying code patterns, general
 to some degree, to accomplish desired behaviour of a program.
 The purpose of \emph{nesC} abstraction layer can be seen as making
 the details of complex coding - with which high degree of modularity
 can be achieved - rather hidden away from the programmer.

  \emph{TinyOS} has become widely adopted and there are many researcher
 who contributed significant work in different application areas, one
 such area of great interest to WMI project is sensor device time
 synchronisation protocols. A number of papers are available and the
 mainstream repository of \emph{TinyOS} source code already contains
 implementations for some of those protocols.
 ( A few details with references needed )
  Further study and experimentation in this area are required to design
 a system which could cope with real-time constraints of stage control
 applications. It is important to note that \emph{P802.15.4} has addressed
 some real-time application requirements, however the status of software
 support for these features of \emph{P802.15.4} is currently uncertain.
 ( Perhaps mention NanoRX ? )

\subsubsection{Network Protocols in TinyOS}
 
  After several aspects of \emph{TinyOS} were studied, it was clear
 that its current implementation of \emph{6loWPAN} is fully compatible
 with \emph{Contiki} and it had been desired to prove this in practice.
 However it has not been achieved at the time of writing of this paper.
  
  A problem exists however, there was no fully working IP-enabled driver
 for \emph{ATmega128RFA1} transceiver. The IP layers are provided by
 \emph{BLIP} stack (this stands for Berkley Lightweight IP), the stack
 is currently undergoing major development. Details on what is required
 are available on \emph{TinyOS} wiki page \cite{tinyos:wiki:blip-2-0},
 implementing it in \emph{nesC} was not as trivial due to the learning
 curve. Therefore this task had be postponed.

  This problem requires further explanation. \emph{TinyOS} has been
 developed since 2001, while \emph{Contiki} first dates back to two
 years later - 2003\footnote{\emph{No exact information has been
 found, these are the earlies dates which appear in the source code.}}. 
 In the early days of WSN research \emph{P802.15.4} and \emph{ZigBee}
 where still emerging, the \emph{6loWPAN} RFCs appeared at IETF more
 recently\footnote{\emph{First revision of P802.15.4 was released in
 2003 (latest revision in 2006) and first draft of 6loWPAN is dated
 April 2007.}}. \emph{TinyOS} has originally used its own protocol
 called \emph{ActiveMessage}.

  Currently \emph{BLIP} stack was released by UC Berkley WEBS Wireless
 Embedded Systems research group in the summer 2008, know as \emph{
 bl6lowpan} then \cite{ucb:webs:blip}. As mentioned below, at the time
 of writing major code changes had been still in progress. The driver
 code which fully implements all new features of \emph{BLIP} stack
 (including point-to-point tunnelling for USB connectivity) is only
 for the most popular \Chip{CC2420} radio chips.

\subsubsection{Hardware Resources}

 There is a large repository of board design files featuring so called
 \emph{Epic Mote} platform, that is base around \Chip{CC2420} and the
 \Chip{MSP430} \cite{epic:homepage}. The most interesting device
 designed by Prabal Duta \cite{duta:homepage} is shown in Figure
 \ref{fig:mote:quanto}. The reason why it is so interesting is because
 features \Chip{Digi Connect ME} microprocessor system block that is
 of standard RJ45 form factor \cite{digi:connect-me}. This tiny device
 has 55MHz ARM7TDMI CPU, 4MB of flash and 8MB of SDRAM as well as
 hardware cryptographic unit and capable of running Linux OS.


% INCLUDE THIS IMAGE:
% http://www.cs.berkeley.edu/~prabal/projects/epic/epic-quanto.jpg

\subsubsection{Conclusion}

  Several step were made in attempt to bring up \emph{TinyOS} on the
 hardware chose for this project earlier, though it appeared rather
 unmanageable withing the give time frame. This is still a subject
 of interest and shall be look into at a later time.
 %FOOTNOTE https://github.com/errordeveloper/tinyos-wmi/commits/wmi-work?author=errordeveloper

%% to be added to the bibtex file:

 %http://www.cs.berkeley.edu/~prabal/projects/epic/
 %http://www.cs.berkeley.edu/~prabal/
 %http://www.digi.com/products/wireless-wired-embedded-solutions/solutions-on-module/digi-connect/digiconnectme.jsp
 %http://smote.cs.berkeley.edu:8000/tracenv/wiki/blip
 %http://docs.tinyos.net/index.php/BLIP_2.0_Platform_Support_Guide
 %http://standards.ieee.org/getieee802/download/802.15.4-2006.pdf
 %http://standards.ieee.org/getieee802/download/802.15.4-2003.pdf
 %http://tools.ietf.org/pdf/rfc4944.pdf


\section{Contiki OS Development Platform}

  Examining the code for various hardware platforms in the source
 tree of \emph{Contiki OS}, it was understood that \chip{MC1322x}
 devices from \emph{Freescale} is organised in a much clearer way.
 Current implementation appeares to support most of important
 features of these chips and in general these are very robust
 devices. As mentioned earlier \Chip{MC1322x} is an \Chip{ARM7TDMI}
 microcontroller with fully integrated radio and the only component
 external to the chip itself is the antenna. Apart from this, the
 \emph{Freescale} device has an outstanding set of peripheral and
 rather large amount of memory (128KB of flash, 96KB of RAM and
 80K of ROM) the processor clock frequency is 24MHz.
 Below is the diagram of \Chip{MC1322x} \emph{Platform in Package}
 \emph{PiP}.
% INCLUDE THIS IMAGE:
% http://cache.freescale.com/files/graphic/block_diagram/2150_MC1322X_BD.gif

  In addition to standard peripherals (UART, 12 A/D converters,
 SPI and I2C) this device has Synchronous Serial Interface (SSI)
 that would allow communication with I2S devices as well other
 synchronous serial peripherals. Being a 32-bit microcontroller
 it can be used for some basic audio signal processing. For example,
 with \emph{Analog Devices} \Chip{ADMP441} omnidirectional microphone
 with 24-bit I2S digital output \cite{datasheet:adi:ADMP441} an
 acoustic measurement sensor node can be designed. According to the
 datasheet, \Chip{ADMP441} has a very linear frequency response in
 the band between 100Hz to 15kHz. Such wireless node would be
 suitable for field noise measurement at popular music festivals
 or construction sites and industrial areas.
 Another sensor that could be included on such board would be an
 accelerometer, according to \emph{Freescale Application
 Note AN3751} \cite{appnote:freescale:AN3751} by utilising standard
 DSP techniques on accelerometer signal data, various vibration
 frequency analysis results can be produced.

%% to be added to the bibtex file:

 %http://www.freescale.com/files/rf_if/doc/ref_manual/MC1322xRM.pdf
 %http://www.freescale.com/files/rf_if/doc/app_note/AN3751.pdf
 %http://www.analog.com/static/imported-files/data_sheets/ADMP441.pdf
 
%% write about freescale usb stick and the Econotag, include circuits

%%%%% last part

%% FINAL PRODUCT vs DEVELOPMENT SYSTEM

\subsection{DSP Host Hardware}

  A set of hardware platforms suitable for DSP host were considered.
 Among those are the fallowing:
 	\begin{itemize}
		\item \emph{x86} (\emph{Intel} and other vendors)
		\item \emph{OMAP} (\emph{Texas Instruments})
		\item \emph{SHARC} (\emph{Analog Devices})
		\item \emph{Sheeva} (\emph{Marvell})
	\end{itemize}
 All of these processor architectures are fully supported and widely
 used in embedded systems. There various other architecture families
 which were considered to be rather inappropriate due to price range
 dictated by the target market are. Device such as \emph{NetLogic
 MIPS64} many-core system on chip \cite{netlogic:mips64:multicore},
 for example, have very large computational capacity, thought it is
 to expensive for this system to use.

\subsubsection{x86}

\subsubsection{OMAP}

  The \emph{OMAP} application processors form \emph{TI} has become
 popular in the open-source community, and in fact \emph{TI} promotes
 \emph{Linux} and \emph{Android} as most suitable operating systems
 for this platform. The \emph{OMAP} architecture is based around
 an \emph{ARM} processor (there various models with different version
 of \emph{ARM} core) and \emph{TI DSP} block. There one little problem
 associated with how the DSP unit is integrated, there is very little
 documentation on how it can be used in \emph{Linux} environment
 \cite{ti:omap:wiki:dsp}. The most outstanding platform which uses
 one of the latest \emph{OMAP} chips is the \emph{PandaBoard}
 \cite{ti:omap:wiki:pb}, however it is available for back-order only,
 the maker is producing these boards on demand. \emph{TI} does
 promote the \emph{PandaBoard}, though does appear to support sales.
 %http://www.omappedia.org/wiki/DSPBridge_Project
 %http://www.omappedia.org/wiki/PandaBoard


\subsection{Conclusion}

  It had been desired to build an embedded DSP host system as one of
 addition project targets, however due to various limitations, including
 the time frame, the project has not achieved this at the time of
 writing of the final report.

