%% in introduction part:

  The major emphasis of this project had been in the area of development
 tools, platforms and code architecture for embedded software design.
 Though originally it was intended as application development project,
 study of various alternatives of how the task can be achieved lead to
 extended research in embedded operating systems and various programming
 tools (namely compiler toolchains, cross-platform integration techniques
 as well as languages).
  One of initial interest areas had been in the field of networking protocols
 for wireless sensor networks. Current best practice suggests that IP-enabled
 networking technology is most suitable for its global adoption, hence simple
 to integrate with various existing applications. It is rather difficult to
 imagine where in the modern technology world a non-IP network may be useful.%% 
 The closes reference to this can be found in papers published by IPSO 
 \cite{IPSO_PAPERS} and general industry trends. Certainly non-IP networking
 technology is available on the market, however if such device are going to
 used for any application, there are several limitations imposed on integration
 into various existing infrastructures. That implies physical connectivity
 as well as software support. One example is the popular \emph{ZigBee}
 family of protocols, is apparently gaining popularity, thought no global
 scale of deployment has been observed. Instead most of research papers
 are oriented towards the use of IP-enabled networks for wireless sensing.

%%%

  As stated in the interim report, the task which was still to be
 completed then had been the development of radio transceiver driver
 code for the chosen platform (\Chip{ATmega128RFA1}). After spending
 several hours of work, it has been understood that there are various
 in portability of \emph{AVR} architecture code. The \emph{AVR} branch
 of \emph{Contiki OS} (in its current state) has almost no facility to
 aid porting task for various \emph{AVR} devices which may be of some
 interest. Comparing currently available \emph{Atmel AVR} microcontroller
 models \cite{atmel:avr:table}, it is rather clear that OS support for
 this architecture can be generalised to much higher degree then what is
 currently provided by the \emph{Contiki OS}. Due to the time limit for
 this project, various alternatives were considered.



%%%%% last part

%% FINAL PRODUCT vs DEVELOPMENT SYSTEM

\subsection{DSP Host Hardware}

  A set of hardware platforms suitable for DSP host were considered.
 Among those are the fallowing:
 	\begin{itemize}
		\item \emph{x86} (\emph{Intel} and other vendors)
		\item \emph{OMAP} (\emph{Texas Instruments})
		\item \emph{SHARC} (\emph{Analog Devices})
		\item \emph{Sheeva} (\emph{Marvell})
	\end{itemize}
 All of these processor architectures are fully supported and widely
 used in embedded systems. There various other architecture families
 which were considered to be rather inappropriate due to price range
 dictated by the target market are. Device such as \emph{NetLogic
 MIPS64} many-core system on chip \cite{netlogic:mips64:multicore},
 for example, have very large computational capacity, thought it is
 to expensive for this system to use.

\subsubsection{x86}

\subsubsection{OMAP}

  The \emph{OMAP} application processors form \emph{TI} has become
 popular in the open-source community, and in fact \emph{TI} promotes
 \emph{Linux} and \emph{Android} as most suitable operating systems
 for this platform. The \emph{OMAP} architecture is based around
 an \emph{ARM} processor (there various models with different version
 of \emph{ARM} core) and \emph{TI DSP} block. There one little problem
 associated with how the DSP unit is integrated, there is very little
 documentation on how it can be used in \emph{Linux} environment
 \cite{ti:omap:wiki:dsp}. The most outstanding platform which uses
 one of the latest \emph{OMAP} chips is the \emph{PandaBoard}
 \cite{ti:omap:wiki:pb}, however it is available for back-order only,
 the maker is producing these boards on demand. \emph{TI} does
 promote the \emph{PandaBoard}, though it is not made by \emph{TI}.
 %http://www.omappedia.org/wiki/DSPBridge_Project
 %http://www.omappedia.org/wiki/PandaBoard

\subsection{ARM Cortex}

% Freescale i.MX family info:
% http://cache.freescale.com/files/32bit/doc/brochure/FLYRIMXPRDCMPR.pdf
%^% NO DETAILS ABOUT NEON/VFP specified !!

% i.MX31 - mid range (532 MHz ARM1136JF-S)
% i.MX31 has VFP:
% http://www.freescale.com/webapp/sps/site/prod_summary.jsp?code=i.MX31
% http://www.freescale.com/files/32bit/doc/ref_manual/MCIMX31RM.pdf
%^% NOT MUCH APART FROM THE VFP.

% i.MX53 - top end of the family (1 GHz ARM Cortex-A8)
% i.MX535 and i.MX538 Applications Processors Fact Sheet 
% http://www.freescale.com/webapp/sps/site/overview.jsp?code=IMX53_FAMILY
% http://cache.freescale.com/files/32bit/doc/fact_sheet/IMX5CNFS.pdf
%^% IT SAYS THAT A BASIC DEV BOARD IS JUST $150, WITH TOUCHSCREEN - $200
% i.MX538 has NEON and VFP + SATA:
% http://www.freescale.com/webapp/sps/site/prod_summary.jsp?code=i.MX538
% http://www.freescale.com/files/32bit/doc/ref_manual/iMX53RM.pdf

\subsection{Building Embedded Linux OS}


\subsubsection{Background}

  Until quite recently, it had been rather more difficult to achieve
 the task of building embedded (custom) Linux system. Traditionally,
 the engineer who desired to do so, would need to follow instruction
 provided in the reference book \emph{"Linux from Scratch"}, commonly
 known as \emph{LFS} \cite{book:lfs}. This text provides details on
 how to utilise various tools for building an embedded Linux kernel
 and the file system from source, it discusses how to tweak various
 features at build time and configure appropriate runtime services.

\subsubsection{Build Utilities}
 
  More recently an number of project emerged, which do a
 great job of extending the flexibility by automating some of the
 simpler task, e.g. package dependency tracking and build version
 control (enabling the maintainer to revert to previous builds).
 One of the most outstanding and widely used projects in the areas
 is \emph{OpenEmbedded} \cite{links:oe} it has recently been adopted
 by a major software company \emph{Mentor Graphics}. \emph{Mentor
 Embedded Linux} extends \emph{OpenEmbedded} framework with a set
 of tools which are useful in a large-scale development project.
 
  There a few alternative approaches which lead to similar results,
 one may wish to use \emph{Gentoo Linux} meta-distribution.
 Generally, there is no big difference between \emph{Gentoo} and
 \emph{OpenEmbedded}. Many internals are know to be very similar,
 tough \emph{Gentoo} doesn't provide some specialised tools which 
 are provided in \emph{OpenEmbedded}, hence \emph{Gentoo} has been
 originally designed for custom desktop and server systems.
 The conclusion is that \emph{OpenEmbedded} is most like to be
 more convenient to use for an embedded target.
 

\subsection{Conclusion}

  It had been desired to build an embedded DSP host OS as one of
 additional project targets, however due to various limitations, most
 importantly - the time frame, the project has not achieved this at
 the time of writing of the final report. The above section had included
 to provide the evidence of research in this area.

